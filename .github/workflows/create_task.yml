name: Tasks to Issues

on:
  workflow_dispatch:
    inputs:
      project_identifier:
        description: 'docs/{project_identifier}/tasks 配下を対象（未指定なら全体）'
        required: false
      update_existing:
        description: '同名タイトル or 同一 Task-ID の既存Issueを更新する'
        type: boolean
        default: true

permissions:
  contents: read
  issues: write

jobs:
  create:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Collect task files
        id: collect
        run: |
          set -euo pipefail
          # 対象ファイルのリストアップ
          if [ -n "${{ inputs.project_identifier }}" ]; then
            mapfile -t arr < <(find "docs/${{ inputs.project_identifier }}/tasks" -maxdepth 1 -type f -name "*.md" ! -iname "README.md" 2>/dev/null | sort || true)
          else
            mapfile -t arr < <(find docs -path "*/tasks/*.md" -type f ! -iname "README.md" | sort || true)
          fi

          # JSON形式に変換してOutputに格納
          json=$(printf '%s\n' "${arr[@]:-}" | jq -c -R -s 'split("\n")|map(select(length>0))')
          echo "list=${json}" >> "$GITHUB_OUTPUT"

      - name: Create or Update issues
        if: ${{ steps.collect.outputs.list != '[]' && steps.collect.outputs.list != '' }}
        uses: actions/github-script@v7
        env:
          LIST_JSON: ${{ steps.collect.outputs.list }}
          UPDATE_EXISTING: ${{ inputs.update_existing }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;

            // 1. レート制限対策：最初に全てのオープンIssueを一括取得（検索APIを使わない）
            core.info('Fetching all open issues for matching...');
            const allOpenIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const files = JSON.parse(process.env.LIST_JSON);
            const updateExisting = process.env.UPDATE_EXISTING === 'true';

            for (const file of files) {
              if (!fs.existsSync(file)) continue;
              const raw = fs.readFileSync(file, 'utf8');

              // タイトルの抽出
              const titleMatch = raw.match(/^#\s+(.+)\s*$/m);
              const title = titleMatch ? titleMatch[1].trim() : `Task: ${file.split('/').pop()}`;

              // Task-ID / Labels の抽出
              const idMatch = raw.match(/^Task-ID:\s*(.+)\s*$/m);
              const taskId  = idMatch ? idMatch[1].trim() : null;
              const labelsMatch = raw.match(/^Labels:\s*(.+)\s*$/m);
              const labels = labelsMatch ? labelsMatch[1].split(',').map(s=>s.trim()).filter(Boolean) : ['implementation','autogen'];

              let existingIssue = null;
              if (updateExisting) {
                // 2. メモリ上で既存のIssueを検索（Task-ID優先、次にタイトル）
                existingIssue = allOpenIssues.find(i => {
                  const hasId = taskId && i.body && i.body.includes(`Task-ID: ${taskId}`);
                  const hasTitle = i.title === title;
                  return hasId || hasTitle;
                });
              }

              const body = raw;

              if (existingIssue) {
                core.info(`Updating #${existingIssue.number}: ${title}`);
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: existingIssue.number,
                  title,
                  body,
                  labels // updateで一気にラベルも更新可能
                });
              } else {
                core.info(`Creating: ${title}`);
                const created = await github.rest.issues.create({
                  owner,
                  repo,
                  title,
                  body,
                  labels
                });
                core.notice(`Created #${created.data.number} for ${file}`);
              }

              // 短時間に大量の書き込みAPIを叩くのを防ぐため、わずかに待機（必要に応じて）
              await new Promise(resolve => setTimeout(resolve, 200));
            }
